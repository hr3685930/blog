# mysql调优
## 场景
  一般应用读写比例大概在10:1
  IO成本磁盘大概是内存的十万倍
  高负载读应用支持千万量级数据，高负载写应用支持百万量级数据
  索引采用了高可用多路搜索树构（B+Tree，非叶子节点不存储真实的数据，只存储指引搜索方向的数数项）
  索引查询遵循最左前缀匹配原则

## 数据设计阶段
		1. 表引擎选择  
    高频插入、更新的表使用InnoDB引擎  
    高频读取的表使用MyISAM引擎  
		2. 字段设计  
    尽可能小的字段类型  
    NOT NULL(避免NULL比较)  
    字段约束默认值(减少插入次数)  
    ENUM代替String类型（ENUM被当做数值类型处理，这条较少运用）
		3. 合理利用索引  
    索引建立原则
			- UNIQ索引优先于INDEX索引 选择区分度高的where、order列创建索引（区分度小于0.3查询计划会忽略索引，唯一键的区分度是1）
			- 尽量的扩展复合索引，不要新建索引  
			- 范围查询>、<、between、like列放在复合索引构建字段集的的末尾（复合索引查询向右匹配直至范围查询列而止）
    索引使用原则
			- where的列顺序不做要求，查询计划会自动调整以匹配复合索引列顺序  
			- 批量数据插入前应先删除索引，结束后再重建
		4. 冗余字段  
			- 适当添加的字段冗余能减少多表查询，提高查询效率
			- 空间换时间
		5. 简化权限设置  
			- sql查询前的权限判断有较高的时间损耗

## 查询阶段
		1. 小表驱动大表查询  
    可以考虑在FROM之后利用子查询，尽可能的在最终查询前缩减表规模  
    如：select x.* from (select * from a where id < 100) as x left join b on b.extid= x.id
		2. 避免在FROM之前使用子查询  
    应改为JOIN代替，否则主表每条记录都会进行一次子查询产生笛卡尔积问题，占用大量内存资源  
    如：select a.*, (select x from y where extid = a.id) as b from a
		3. 字段比较使用相同数据类型  
    避免字段比较时发生类型转换，类型转换可能还会导致索引无效
* ##SQL调优阶段

		1. 慢查日志  
    慢查日志能记录应用运行期间超出时间阈值的慢查询

		2. Show Profile分析  
    sql语句性能分析，查找效率瓶颈

		3. Explain分析慢查语句  
    设置SQL_NO_CACHE并Explain分析查询的执行计划  
    查询序列号越大, 优先级越高，越先被执行  
    查询计划，优先排序表，其次锁定记录较少的where单表  
    留意查询计划中 索引使用、扫描行数 等指标

## 连接优化阶段
		1. 连接参数调优  
    最大并发连接数max_connections、max_user_connections  
    最大请求暂存堆栈数back_log  
		2. mysql线程缓存池复用连接  
    配置thread_cache_size参数（每G内存可以配备8个连接线程，但要小于数据库连接数限制）
		3. mysql长连接在超时内复用连接  
    中间件维护连接池复用连接  
    可通过swoole来实现连接池  

## 架构优化阶段
		1. 设计冗余中间表  
    将高耗时的子查询结果集装载到一张冗余中间表中
		2. 复制特性做主从  
    读写分离  
    自动故障切换避免单点问题  
		3. 垂直分库分表  
    大表拆小表，不常用字段移植到新建表中，减小单表规模  
    为了后期的水平拓展优化，这里要求禁用 join查询、子查询等  
		4. 水平拓展策略 - 分库分表  
    该措施会在后期造成较多的开发、运维困难，不到万不得已不建议实施  
    利用 MOD、HASH、月分表 等shard方案减小单表规模  
		5. 应用/数据库之间架设缓存层 尽量避免请求直接穿透到数据库

## 日常维护阶段
    OPTIMIZE语句  
    空间回收、数据重排、更新统计等工作  
    设备升级 使用RAID、SSD等高速IO设备 切换到云数据库