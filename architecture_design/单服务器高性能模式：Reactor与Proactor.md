# 单服务器高性能模式：Reactor与Proactor
IO操作分两个阶段
1、等待数据准备好(读到内核缓存)
2、将数据从内核读到用户空间(进程空间)
一般来说1花费的时间远远大于2。
1上阻塞2上也阻塞的是同步阻塞IO
1上非阻塞2阻塞的是同步非阻塞IO，这讲说的Reactor就是这种模型
1上非阻塞2上非阻塞是异步非阻塞IO，这讲说的Proactor模型就是这种模型


 Reactor 模式有这三种典型的实现方案：
1. 单 Reactor 单进程 / 线程。
2. 单 Reactor 多线程。
3. 多 Reactor 多进程 / 线程。


提高服务器性能在IO层需要关注两个地方，一个是文件描述符处理，一个是线程调度。
IO复用是什么？IO即Input/Output，在网络编程中，文件描述符就是一种IO操作。


为什么要IO复用？
1.网络编程中非常多函数是阻塞的，如connect，利用IO复用可以以非阻塞形式执行代码。
2.之前提到listen维护两个队列，完成握手的队列可能有多个就绪的描述符，IO复用可以批处理描述符。
3.有时候可能要同时处理TCP和UDP，同时监听多个端口，同时处理读写和连接等。


为什么epoll效率要比select高？
1.在连接数量较大的场景，select遍历需要每个描述符，epoll由内核维护事件表，只需要处理有响应的描述符。
2.select本身处理文件描述符受到限制，默认1024。
3.效率并不是绝对的，当连接率高，断开和连接频繁时，select不一定比epoll差。所以要根据具体场合使用。

Epoll的两种模式，电平触发和边沿触发。
1.电平触发效率较边沿触发低，电平触发模式下，当epoll_wait返回的事件没有全部相应处理完毕，内核缓冲区还存在数据时，会反复通知，直到处理完成。epoll默认使用这种模式。
2.边沿触发效率较高，内核缓冲区事件只通知一次。

第一次学epoll时，容易错误的认为epoll也可以实现并发，其实正确的话是epoll可以实现高性能并发服务器，epoll只是提供了IO复用，在IO“并发”，真正的并发只能通过线程进程实现。
那为什么可以同时连接两个客户端呢？实际上这两个客户端都是在一个进程上运行的，前面提到过各个描述符之间是相互不影响的，所以是一个进程轮循在处理多个描述符。


Reactor模型： 
1 向事件分发器注册事件回调 
2 事件发生 
4 事件分发器调用之前注册的函数 
4 在回调函数中读取数据，对数据进行后续处理 
Reactor模型实例：libevent，Redis、ACE

Proactor模型： 
1 向事件分发器注册事件回调 
2 事件发生 
3 操作系统读取数据，并放入应用缓冲区，然后通知事件分发器 
4 事件分发器调用之前注册的函数 
5 在回调函数中对数据进行后续处理 
Preactor模型实例：ASIO


reactor和proactor的主要区别：

1. 主动和被动
以主动写为例： 
Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完处理后续逻辑； 
Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑；
可以看出，Reactor被动的等待指示事件的到来并做出反应；它有一个等待的过程，做什么都要先放入到监听事件集合中等待handler可用时再进行操作； 
Proactor直接调用异步读写操作，调用完后立刻返回；
2. 实现
Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应；
Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）

3. 优点
Reactor实现相对简单，对于耗时短的处理场景处理高效； 
操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性； 
事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁； 
事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来，

Proactor性能更高，能够处理耗时长的并发场景；

4. 缺点
Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；

Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现；

5. 适用场景
Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序； 
Proactor：异步接收和同时处理多个服务请求的事件驱动程序；



## 其他

### Goroutine是银弹么？
Goroutine很大程度上降低了并发的开发成本，是不是我们所有需要并发的地方直接go func就搞定了呢？
Go通过Goroutine的调度解决了CPU利用率的问题。但遇到其他的瓶颈资源如何处理？比如带锁的共享资源，比如数据库连接等。互联网在线应用场景下，如果每个请求都扔到一个Goroutine里，当资源出现瓶颈的时候，会导致大量的Goroutine阻塞，最后用户请求超时。这时候就需要用Goroutine池来进行控流，同时问题又来了：池子里设置多少个Goroutine合适？
所以这个问题还是没有从更本上解决。


### Actor模型

### Golang CSP

### Rust

