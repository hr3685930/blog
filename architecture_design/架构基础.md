# 架构基础

## 复杂度来源
### 高性能
高性能需要带来的复杂度：
1.主要有为了高性能单台服务器内部的复杂度；以及为了高性能多台服务器集群带来的复杂度。
2.单机复杂度主要体现为：多线程和多进程。操作系统调度的最小单位是线程，操作系统分配资源的最小单位是进程。进程间通讯的方法有：管道、消息队列、信号量、共享存储。完成一个高性能的软件系统，需要考虑如多进程、多线程、进程间通、多线程并发等，这些技术并不是最新的就是最好的，也不是非此即彼的选择。
3.集群的复杂度主要体现为：任务分配和任务分解。任务分配主要指在不优化拆分任务的前提下，粗暴的增加机器，以提高性能的方法。任务分解主要指在将大任务进一步细分，得到子任务或者叫子系统，进而更进一步优化这些子系统，并将大任务分配到不同的机器上提高性能的方法。集群不是越多越好，机器越多，复杂度越高（任务分配和状态保持的难度和复杂度越来越高），提升效率越低（考虑到网络损耗和机器本身的损耗）


### 高可用
核心思想：网站高可用的主要技术手段是服务与数据的冗余备份与失效转移。同一服务组件部署在多台服务器上；数据存储在多台服务器上互相备份。通过上述技术手段，当任何一台服务器宕机或出现各种不可预期的问题时，就将相应的服务切换到其他可用的服务器上，不影响系统的整体可用性，也不会导致数据丢失。

从架构角度看可用性：当前网站系统多采用经典的分层模型，从上到下为：应用层、服务层与数据层。应用层主要实现业务逻辑处理；服务层提供可复用的服务；数据层负责数据读写；在部署架构上常采用应用和数据分离部署，应用会部署到不同服务器上，这些服务器被称为应用层的服务器；这些可复用的服务也会各自部署在不同服务器上，称为服务层的服务器；而各类数据库系统、文件柜等数据则部署在数据层的服务器。

### 可扩展性
可扩展性的思路：抽象、分层。

### 低成本、安全、规模
规模是引发一切问题的根源
1、规模小，功能简单，数据少，基本上就不会存在太大的性能问题，系统简单稳定高可用，顶多加个主从备份，不需要扩展，
单机就能支持成本比较低
2、规模大
     （1）功能越来越多，越来越复杂，可能引发性能问题，必要时进行系统拆分，原先设计扩展性差需要重构
     （2）业务数据大，数据的存储难度，读写速度，需要引入相关大数据技术。
     系统部署更多机器，成本上升，各系统间调用如何保证高可用

一般而言安全方面主要由专门安全团队负责，不大考虑。


## 架构设计三原则
### 合适原则

合适原则: 有多大的脚（复杂度），穿多大码的鞋。BAT或者业界领先的架构对很多团队和公司来说都是大码的鞋而已，穿上不合适的鞋，团队必定步履蹒跚，很难走的很远，还有可能摔倒（项目失败）。
但是如果能根据自己的业务需求，对BAT或者业界领先的架构进行仔细调研，进行删减，重新取其一部分组合成适合自己的架构，也是非常好的方法。

### 简单原则
简单原则: 我感觉改成简洁原则更合适，简单+整洁。360行皆是艺术，架构也是一门艺术。一个复杂的系统，如果能用一个简洁的架构来实现，完全相当于一个艺术品。 相反，如果一个普通的系统，反而被设计成了一个错综复杂的复杂架构，相当于做了一个糟粕品。

### 演进原则
演化原则: 通过 简化设计 + 重构 来保证架构的与时俱进。不要前期就对架构进行过度设计，毕竟无论你前期怎么设计，总会有你意想不到的变化产生，唯一不变的就是变化。等你的脚长大了，再去穿大码的鞋。

## 架构设计流程
### 识别复杂度
例如，如果一个系统的复杂度本来是业务逻辑太复杂，功能耦合严重，架构师却设计了一个 TPS 达到 50000/ 秒的高性能架构，即使这个架构最终的性能再优秀也没有任何意义，因为架构没有解决正确的复杂性问题。

> 对于架构师来说，常见系统的性能量级需要烂熟于心，例如nginx负载均衡性能是3万左右，kafka号称百万级，zookeeper写入读取2万以上，http请求访问大概在2万左右。  
> 具体的数值和机器配置以及测试案例有关，但大概的量级不会变化很大。如果是业务系统，由于业务复杂度差异很大，有的每秒500请求可能就是高性能了，因此需要针对业务进行性能测试，确立性能基线，方便后续架构设计做比较。  

微服务架构，是解决了什么复杂性问题呢?   ——可扩展


## 实战




提升性能：
先单机，有压力后优先考虑sql优化、db参数调优，还有硬件性能(32核/16G/SSD)优化，不行还可以再考虑业务逻辑优化、缓存。不要一上来就读写分离、集群等，能单库搞定的就毫不犹豫的单库。

主从读写分离
读写分离适合读压力比写压力大很多的业务类型，最终的瓶颈应该是出现在承担写操作的主机上
适用于单机无法应付所有请求，且读比写多时，读写分离还可以分别针对读写节点建索引来优化。
对实时性要求不高：刚写入就读会有延迟，同步数据特别大时，延迟可能达到分钟级（可用缓存解决：2-8原则，挑选占访问量80%的前20%来缓存）。
TODO主从还能设置自增长key不一样？

分库分表（甚用，增加很多复杂度）
几千万或上亿
分库时机：单机性能瓶颈，1业务不复杂，但整体数据量影响到数据库性能；2业务复杂，需要分系统由不同团队开发，使用分库减少团队耦合。（分库导致不能join和事务（有方案但性能太低用了跟没分库差别不大，用最终一致性/事件驱动））
分表时机：单表数据量大拖慢了sql性能，做垂直（将常用和不常用字段分开）或水平拆分（id分段、hash路由、添加路由表等）提高速度。（那么join、count、分页排序等就变得复杂）
TODO环状hash 一致性hash？

nosql
（nosql——not noly sql 本质上是牺牲ACID中的某个或某几个属性，以解决关系数据库某些复杂的问题）
关系数据库：强大的sql功能和ACID属性，发展了几十年技术相当成熟 Mysql / Postgresql
K-v存储：解决关系数据库无法存储数据结构的问题 Redis / Memcache （redis不太适合key的value特别大，这种情况会导致整个redis变慢，这种场景mc更好->参考IO模型 redis单Reactor单进程读写大value会阻塞所有业务 持久化也会）
文档数据库：解决关系数据库强schema约束，查询不存在的列会报错，扩充很麻烦还会长时间锁表 MongoDB
列式数据库：解决关系数据库处理大数据分析或统计时IO高的问题，关系数据库即使只处理某列也会把整行查询到内存中 HBase / Greenplum
全文搜索引擎：解决关系数据库全文搜索like扫描全表性能问题 ElasticSearch / solr
LevelDB 内存型？
时序数据库？：实时计算统计实时监控 influxDB
OLAP OLTP HTAP？

缓存（千万千万不要设计复杂的缓存，到时候各种不一致问题烦死你）
Cdn、nginx缓存、网关缓存、数据层缓存redis、db本身也有缓存(sql结果缓存、读取的磁盘分页缓存)
缓存穿透：1本身无数据(添加默认值缓存/布隆过滤器[整型自增key？]) 2未生成缓存(识别爬虫并禁止 但可能影响seo)
缓存雪崩：缓存实效后大家都在更新缓存导致系统性能急剧下降（1消息队列通知后台更新、2使用分布式更新锁）
缓存热点：大部分业务都会命中的同一份缓存，比如1000w+粉丝的微博消息，复制多分缓存副本，key里面加副本编号将请求分散，且设置过期范围，而不是所有副本固定同一过期时间。
缓存框架看一下设计思路：echcache



