# 高性能负载均衡

并发数：同一时刻的接收的访问数量，时间单位一般用秒，也可以用分钟和小时，常见有并发请求数，并发连接数

QPS：query per second，指查询类请求

日活：每日活跃用户数，指当天来访问过系统的用户，同一用户，无论用户访问多少功能和页面都只算一个用户


日活千万的论坛，这个流量不低了。

1、首先，流量评估。
1000万DAU，换算成秒级，平均约等于116。

考虑每个用户操作次数，假定10，换算成平均QPS=1160。

考虑峰值是均值倍数，假定10，换算成峰值QPS=11600。

考虑静态资源、图片资源、服务拆分等，流量放大效应，假定10，QPS*10=116000。 

2、其次，容量规划。

考虑高可用、异地多活，QPS*2=232000。

考虑未来半年增长，QPS*1.5=348000。

3、最后，方案设计。

三级导流。

第一级，DNS，确定机房，以目前量级，可以不考虑。

第二级，确定集群，扩展优先，则选Haproxy/LVS，稳定优先则选F5。

第三级，Nginx+KeepAlived，确定实例。



* 根据负载均衡达到的目的可分四类
		* 任务平分类：负载均衡系统收到任务平均分配给服务器进行处理，可以是绝对的平均，也可以是按比例的“加权”平均
		* 负载均衡类：突出负载的均衡，根据当前系统压力
				* CPU负载
				* IO负载
				* 网卡吞吐量
		* 性能最优类：根据服务器响应时间来任务分配
		* Hash类：根据某些关键信息进行Hash运算，同一个放在同一服务器上处理
				* 源地址hash
				* 目标地址hash
				* session ID hash
				* 用户ID hash
* 轮询
		* 优点简单
		* 缺点不关心服务器状态
				* 如果有一个服务器死循环CPU过高，还是会发送任务
* 加权轮询
		* 根据不通服务器的配置差异，不同的权重设置
* 负载最低优先
		* 不同任务类型、不同业务场景、选择不同指标
				* LVS是4层负载，以连接数来判断服务器状态
				* Nginx是7层负载，以HTTP请求数来判断服务器状态
		* 自己开发，还需要注意，考虑选择的指标
				* IO密集型
				* CPU密集型
		* 复杂性问题：
				* 连接数优先算法
						* 要求：每个请求都会发送给服务器进行处理
						* 不适合：固定连接池方式
				* CPU负载
						* 收集信息的方式
								* 收集时间长度
										* 1分钟长度与15分钟长度效果不同，并不一定15分钟就好
								* 收集动作消耗性能
				* 代码复杂度
						* 轮询可能10行代码
						* 负载可能1000行
								* 并且需要多方面调试
* 性能最优类
		* 站在客户端进行分配任务
		* 谁的性能此时最好，分配给谁
		* 高复杂度
				* 收集分析过程中，本身收集就会消耗性能
				* 为了减少性能消耗
						* 设置合适的采样率
								* 越大性能消耗越大
						* 合适的周期
								* 多久采样一次
* Hash类
		* 源地址Hash
				* 适合存在事务、会话业务
				* 网上银行：生成临时会话信息
		* ID Hash
				* 根据某个ID的业务分配服务器处理
				* session ID也可以解决网上银行的例子
